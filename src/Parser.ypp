%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.7.1"
%defines

%define api.token.raw

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires {
  #include <string>
  #include <iostream>
  #include <memory>
  #include "AST.hpp"
  #include "Parser.hpp"

  namespace quack::parser
  {
    class ParserDriver;
  }

  using namespace quack::ast;
}

// The parsing context.
%param { quack::parser::ParserDriver& drv }
%locations

%define parse.trace
%define parse.error detailed
%define parse.lac full

%code {
  #include "ParserDriver.hpp"
  #define LOC(BEGIN_TOK, END_TOK) \
    Location(BEGIN_TOK.begin.line, BEGIN_TOK.begin.column, END_TOK.end.line, END_TOK.end.column, BEGIN_TOK.begin.filename)
}

%define api.token.prefix {TOK_}
%token
  ASSIGN  "="
  MINUS   "-"
  PLUS    "+"
  STAR    "*"
  SLASH   "/"
  LESS   "<"
  MORE   ">"
  LESSEQ   "<="
  MOREEQ   ">="
  EQUAL    "=="
  COLON   ":"
  DOT     "."
  SEMICOLON ";"
  LPAREN  "("
  RPAREN  ")"
  LBRACK  "{"
  RBRACK  "}"
;

// associating terminals with types
%token <long> INT
%token <double> FLOAT
%token <bool> BOOL
%token <std::string> STRING_LIT

%token <std::string> THIS
%token <std::string> IDENT
%token <std::string> WEAK
%token <std::string> CLASS
%token <std::string> EXTENDS
%token <std::string> DEF
%token <std::string> RETURN
%token <std::string> IF
%token <std::string> ELIF
%token <std::string> ELSE
%token <std::string> WHILE

%type <std::unique_ptr<TranslationUnit>> translationUnit
%type <std::unique_ptr<Statement>> statement
%type <std::unique_ptr<Identifier>> identifier
%type <std::unique_ptr<CompoundStmt>> compoundStmt
%type <std::unique_ptr<Expression>> expression
%type <std::unique_ptr<VarDecl>> varDecl
%type <std::unique_ptr<Assignment>> assignment
%type <std::unique_ptr<Return>> returnStmt
%type <std::unique_ptr<If>> ifStmt
%type <std::unique_ptr<While>> whileStmt
%type <std::unique_ptr<CompoundStmt>> optElseIf
%type <BinaryOperator::Operator> binaryOperator
%type <std::unique_ptr<Arguments>> args
%type <std::unique_ptr<Arguments>> argsNonEmpty
%type <std::unique_ptr<Parameters>> params
%type <std::unique_ptr<Parameters>> paramsNonEmpty
%type <std::unique_ptr<Method>> method
%type <std::unique_ptr<Methods>> methods
%type <std::unique_ptr<Methods>> methodsNonEmpty
%type <std::unique_ptr<Class>> class
%type <std::unique_ptr<Classes>> classes
%type <std::unique_ptr<Classes>> classesNonEmpty
%type <std::unique_ptr<Call>> call
%type <std::unique_ptr<MemberAccess>> memberAccess

// Precedence
%left "="
%left "."
%left "<" ">" "<=" ">=" "=="
%left "+" "-"
%left "*" "/"

%%

%start translationUnit;

/// Root of the AST
translationUnit : classes compoundStmt
{
  $$ = std::make_unique<TranslationUnit>(LOC(@1, @1), std::move($1), std::move($2));
  drv.setRoot(std::move($$));
}
;

compoundStmt: %empty                  { $$ = std::make_unique<CompoundStmt>(LOC(@$, @$)); }
    | compoundStmt statement          { $$ = std::move($1);
                                        $$->append(std::move($2));
                                      }
    ;

identifier: IDENT                   { $$ = std::make_unique<Identifier>(LOC(@1, @1), $1); }
    ;

memberAccess: expression "." identifier
                                    { $$ = std::make_unique<MemberAccess>(LOC(@1, @3), std::move($3), std::move($1)); }
    ;

varDecl: WEAK identifier ":" identifier
                                    { $$ = std::make_unique<VarDecl>(LOC(@1, @4), std::move($2), std::move($4), true); }
    | identifier ":" identifier
                                    { $$ = std::make_unique<VarDecl>(LOC(@1, @3), std::move($1), std::move($3)); }
    | memberAccess ":" identifier   { $$ = std::make_unique<StaticMemberDecl>(
                                          LOC(@1, @3), std::move($1), std::move($3)); }
    ;

assignment: varDecl "=" expression  { $$ = std::make_unique<Assignment>(LOC(@1, @3),std::move($1), std::move($3)); }
    | memberAccess "=" expression   { $$ = std::make_unique<Assignment>(LOC(@1, @3),std::move($1), std::move($3)); }
    | WEAK identifier "=" expression  { auto lValueIdent = std::make_unique<LValueIdent>(
                                            LOC(@2, @2), std::move($2), true);
                                       $$ = std::make_unique<Assignment>(
                                            LOC(@1, @4),std::move(lValueIdent), std::move($4));
                                      }
    | identifier "=" expression  { auto lValueIdent = std::make_unique<LValueIdent>(LOC(@1, @1), std::move($1));
                                   $$ = std::make_unique<Assignment>(LOC(@1, @3),std::move(lValueIdent), std::move($3)); }
    ;

returnStmt: RETURN expression  { $$ = std::make_unique<Return>(LOC(@1, @2), std::move($2)); }
    | RETURN                    { $$ = std::make_unique<Return>(LOC(@1, @1), nullptr); }
    ;

ifStmt: IF expression "{" compoundStmt "}" optElseIf
    { $$ = std::make_unique<If>(LOC(@1, @6), std::move($2), std::move($4), std::move($6)); }
    ;

optElseIf: ELIF expression "{" compoundStmt "}" optElseIf
    {
      $$ = std::make_unique<CompoundStmt>(LOC(@1, @6));
      auto IfStmt = std::make_unique<If>(LOC(@1, @6), std::move($2), std::move($4), std::move($6));
      $$->append(std::move(IfStmt));
    }
    | ELSE "{" compoundStmt "}"     { $$ = std::move($3); }
    | %empty                     { $$ = nullptr; }
    ;

whileStmt: WHILE expression "{" compoundStmt "}"
    { $$ = std::make_unique<While>(LOC(@1, @5), std::move($2), std::move($4)); }
    ;

statement: ";"                      { ; }
    | expression ";"                { $$ = std::make_unique<ValueStmt>(LOC(@1, @2), std::move($1)); }
    | assignment ";"                { $$ = std::move($1); }
    | returnStmt ";"                { $$ = std::move($1); }
    | ifStmt                        { $$ = std::move($1); }
    | whileStmt                     { $$ = std::move($1); }
    ;


binaryOperator: "+"                 { $$ = BinaryOperator::Operator::Plus; }
    | "-"                           { $$ = BinaryOperator::Operator::Minus; }
    | "*"                           { $$ = BinaryOperator::Operator::Times; }
    | "/"                           { $$ = BinaryOperator::Operator::Divide; }
    | "<"                           { $$ = BinaryOperator::Operator::Less; }
    | ">"                           { $$ = BinaryOperator::Operator::Greater; }
    | "<="                          { $$ = BinaryOperator::Operator::LessEqual; }
    | ">="                          { $$ = BinaryOperator::Operator::GreaterEqual; }
    | "=="                          { $$ = BinaryOperator::Operator::Equals; }
    ;

call: expression "." identifier "(" args ")" { $$ = std::make_unique<Call>(LOC(@1, @6), std::move($1), std::move($3),
                                                          std::move($5)); }
    | identifier "(" args ")"                { $$ = std::make_unique<Call>(LOC(@1, @4), nullptr, std::move($1),
                                                          std::move($3)); }
    ;

args: argsNonEmpty                         { $$ = std::move($1); }
    | %empty                               { $$ = std::make_unique<Arguments>(LOC(@$, @$)); }
    ;

argsNonEmpty : expression                  { $$ = std::make_unique<Arguments>(LOC(@1, @1));
                                             $$->append(std::move($1)); }
    | argsNonEmpty "," expression          { $1->append(std::move($3)); $$ = std::move($1); }
    ;

params: paramsNonEmpty                     { $$ = std::move($1); }
    | %empty                               { $$ = std::make_unique<Parameters>(LOC(@$, @$)); }
    ;

paramsNonEmpty : varDecl                   { $$ = std::make_unique<Parameters>(LOC(@1, @1));
                                             $$->append(std::move($1)); }
    | paramsNonEmpty "," varDecl           { $1->append(std::move($3)); $$ = std::move($1); }
    ;

method: DEF identifier "(" params ")" ":" identifier "{" compoundStmt "}"
                                           { $$ = std::make_unique<Method>(
                                                LOC(@1, @10), std::move($4), std::move($2), std::move($7),
                                                std::move($9));
                                           }
    | DEF identifier "(" params ")" "{" compoundStmt "}"
                                           { $$ = std::make_unique<Method>(
                                                LOC(@1, @8), std::move($4), std::move($2),
                                                std::make_unique<Identifier>(LOC(@1, @1), "Nothing"),
                                                std::move($7));
                                           }
    ;

methods: methodsNonEmpty                   { $$ = std::move($1); }
    | %empty                               { $$ = std::make_unique<Methods>(LOC(@$, @$)); }
    ;

methodsNonEmpty : method                   { $$ = std::make_unique<Methods>(LOC(@1, @1));
                                             $$->append(std::move($1)); }
    | methodsNonEmpty "," method           { $1->append(std::move($3)); $$ = std::move($1); }
    ;

class : CLASS identifier "(" params ")" "{" compoundStmt methods "}"
                                           {
                                             $$ = std::make_unique<Class>(LOC(@1, @9), std::move($8),
                                                  std::make_unique<Identifier>(LOC(@2, @2), $2->getName()),
                                                  std::make_unique<Method>(LOC(@1, @9), std::move($4),
                                                  std::make_unique<Identifier>(LOC(@2, @2), $2->getName()),
                                                  std::move($2), std::move($7)));
                                           }
    | CLASS identifier "(" params ")" EXTENDS identifier "{" compoundStmt methods "}"
                                           {
                                            $$ = std::make_unique<Class>(LOC(@1, @11), std::move($10),
                                                std::make_unique<Identifier>(LOC(@2, @2), $2->getName()),
                                            std::make_unique<Method>(LOC(@1, @11), std::move($4),
                                            std::make_unique<Identifier>(LOC(@2, @2), $2->getName()),
                                            std::move($2), std::move($9)), std::move($7)
                                              );
                                           }


classes: classesNonEmpty                   { $$ = std::move($1); }
    | %empty                               { $$ = std::make_unique<Classes>(LOC(@$, @$)); }
    ;

classesNonEmpty : class                   { $$ = std::make_unique<Classes>(LOC(@1, @1));
                                            $$->append(std::move($1)); }
    | classesNonEmpty "," class           { $1->append(std::move($3)); $$ = std::move($1); }
    ;

expression:
      INT                                  { $$ = std::make_unique<IntegerLiteral>(LOC(@1, @1), $1); }
    | FLOAT                                { $$ = std::make_unique<FloatLiteral>(LOC(@1, @1), $1); }
    | BOOL                                 { $$ = std::make_unique<BoolLiteral>(LOC(@1, @1), $1); }
    | STRING_LIT                           { $$ = std::make_unique<StringLiteral>(LOC(@1, @1), $1); }
    | THIS                                 { $$ = std::make_unique<Identifier>(LOC(@1, @1), "this"); }
    | identifier                           { $$ = std::make_unique<LValueIdent>(LOC(@1, @1), std::move($1)); }
    | "(" expression ")"                   { $$ = std::move($2); }
    | call                                 { $$ = std::move($1); }
    | expression binaryOperator expression { $$ = std::make_unique<BinaryOperator>(LOC(@1, @3), $2, std::move($1),
                                                      std::move($3)); }
    | memberAccess                         { $$ = std::move($1); }
    ;
%%

void yy::parser::error (const location_type& l, const std::string& m) {
  std::cerr << "error @" << l << ": " << m << "\n\n";
}